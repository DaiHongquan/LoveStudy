'''
类中的函数叫方法
类中的变量叫属性
做一道西红柿炒鸡蛋
面向过程：使用函数/方法一步步按过程实现。主要用到的是“函数”知识，将每个过程步骤打包成函数，再依次调用。例如自己按照炒菜的步骤亲手制作一道西红柿炒鸡蛋
面向对象：使用类，让对象实现。例如制作一台炒菜机器人，然后告诉机器人做一道西红柿炒鸡蛋。

【类】是【对象】的母板，是一个函数包。类中可以放置函数和变量，然后类中的函数可以很方便的使用类中的变量。
语法：class ClassName(): 类名一般首字母要大写，(): 不能丢 
'''
# 语法：创建一个名为“ClassName”的类，类名一般首字母要大写，(): 不能丢   
class Dog():
    # 如定义一个名为'狗'的类，可以写成class Dog():
    # 定义属性
    dogname = '小黑'
    # 规范：class语句后续的代码块要缩进  
    # 定义类中的函数barking
    def barking():
        print('叫声：汪')
    
    # 如果类方法要调用类属性，需要使用@classmethod声明函数是类方法，使用参数cls作为第一个参数，使用cls.属性名调用
    @classmethod
    def 自我介绍(cls,age):
        print('我的名字是%s，年龄是%s' % (cls.dogname,age))

# 这里需要用 类名+属性名
print('小狗的名字：%s' % Dog.dogname) 
# 增加/修改类属性 类名.变量名=值
Dog.dogname = '小白' 
# 调用类属性
print('小狗的名字：%s' % Dog.dogname) 
# 调用类方法
Dog.barking()
Dog.自我介绍(1)

class 类():
    属性 = '属性'
    # 初始化函数（固定格式__init__(self)，在实例化时自动调用）
    def __init__(self):
        print('实例化成功！')
    def 原始函数(self):
        print('我是原始函数！')

def 新函数(self):
    print('我是重写后的新函数!')

a = 类()  # 实例化
a.原始函数()

# 类属性修改会影响所有未重新赋值的实例属性，实例属性修改只会影响自己本身
a.属性 = '属性3'
类.属性 = '属性2'
# 这里会输出重新赋值的实例属性值，如果实例属性没有重新赋值，则会输出重新赋值的类属性值
print('我是实例属性：' + a.属性)

# 用新函数代替原始函数，也就是【重写类方法】，但不可以实例队形.原始函数 = 新函数
类.原始函数 = 新函数

# 现在原始函数已经被替换了
a.原始函数()

# 继承 class 子类(父类): 子类继承父类 多重继承要求父类是平等的关系
class 成绩单_旧():
    def __init__(self,学生姓名,语文_成绩,数学_成绩):
        self.学生姓名 = 学生姓名
        self.语文_成绩 = 语文_成绩
        self.数学_成绩 = 数学_成绩

    def 打印成绩单(self):
        print(self.学生姓名 + '的成绩单如下：')
        print('语文成绩：'+ str(self.语文_成绩))
        print('数学成绩：'+ str(self.数学_成绩))

    def 打印平均分(self):
        平均分 = (self.语文_成绩 + self.数学_成绩)/2
        print(self.学生姓名 + '的平均分是：' + str(平均分))
# 子类继承父类
class 成绩单_新(成绩单_旧):
    def 打印总分(self):
        总分 = self.语文_成绩 + self.数学_成绩
        print(self.学生姓名 + '的总分是：' + str(总分))


实例_旧 = 成绩单_旧('王明明',99,88)
实例_旧.打印成绩单()
实例_旧.打印平均分()

实例_新 = 成绩单_新('王明明',99,88)
实例_新.打印成绩单()
实例_新.打印平均分()
实例_新.打印总分()